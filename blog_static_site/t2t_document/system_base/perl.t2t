系统管理中 perl脚本常用方法总结 
perl,open file,hash sort,常用方法,特殊变量
8533cc01-0213-47e2-a4ad-2224952c3506


%!Target  : html
%!Encoding: utf-8
%!Options : --toc --enum-title
%!preproc: IMGPATH .
%!postproc(html): @@ <BR>
%!postproc(xhtml): @@ <BR>
%%TOC


在日常系统管理工作中，需要编写脚本来完成特定的功能，如果要实现复杂一些的功能，就需要使用perl脚本了！@@
在编写的过程中，掌握一些常用的技巧和语法就可以完成大部分功能了，也就是2/8原则.


= perl 读写文件 =

- 将文件读取到数组中,进行处理
```
open (IN,"file.txt") ||(die "can not open the file input.txt\n$!");
my @all = <IN>;

foreach $line(@all)
{
	process $line;
}
```

注意:将文件load到数组中，在对数组进行遍历操作,这样子做得缺点是文件很大时,会占据很大内存，当然速度上占优势

- 为节省内存，一般建议如下操作来进行文件读取
```
open (IN,"file.txt") ||(die "can not open the file input.txt\n$!");
while ($line = <IN>)
{
	process $line;
}
```

注意:每次$line = <IN>，文件指针后移,节省内存

- 将一个文件内容读取成一个字符窜 

```
open FH,"data.xml" or die $!;
local $/=undef;
my $scalar = <FH>;
close FH;
print $scalar;
```
注意: 程序中把分隔符**$/** 设置为未定义，分隔符 **$/** 默认情况下是等于回车的，在win32中就是\n.


= perl 正则 =

- 匹配读取文件中的空行
```
 if ( $ine =~ /^$/ ) { print "this line is null"; }
```


= perl 排序 =

```
@sorted = sort { $a <=> $b } @not_sorted #  数值排序  
@sorted = sort { $a cmp $b } @not_sorted # 字符ASCII码值排序 
@sorted = sort { lc($a) cmp lc($b) } @not_sorted # 按字母顺序排序 
```

|| 数值比较 | 字符窜比较 |
| < | lt |
| > | gt |
| <= | le |
| >= | gr |
| == | eq |
| <=> | cmp ||

前面5个运算符号是没有问题的，他们就像数学运算符一样。但是 **<=> 和 cmp**操作符和前面的几个不太一样@@
基本上来说 表达式 **$a <=> $b** 或者 **$a cmp $b** 返回值为 1, 0, -1 三个值，请看下表@@


|| $a 和 $b的关系 | $a <=> $b 的返回值 |
| $a 大于 $b | 1 |
| $a 等于 $b | 0 |
| $a 小于 $b | -1 ||


= Perl 内部特殊变量 =

|| 内部变量 | 变量说明 |
| $- | 当前页可打印的行数,属于Perl格式系统的一部分 |
| $! | 根据上下文内容返回错误号或者错误串 |
| $" | 列表分隔符 |
| $# | 打印数字时默认的数字输出格式 |
| $$ | Perl解释器的进程ID |
| $% | 当前输出通道的当前页号 |
| $& | 与上个格式匹配的字符串 |
| $( | 当前进程的组ID |
| $) | 当前进程的有效组ID |
| $* | 设置1表示处理多行格式.现在多以/s和/m修饰符取代之 |
| $, | 当前输出字段分隔符 |
| $. | 上次阅读的文件的当前输入行号 |
| $/ | 当前输入记录分隔符,默认情况是新行 |
| $: | 字符设置,此后的字符串将被分开,以填充连续的字段 |
| $; | 在仿真多维数组时使用的分隔符 |
| $? | 返回上一个外部命令的状态 |
| $@ | Perl解释器从eval语句返回的错误消息 |
| $[ | 数组中第一个元素的索引号 |
| $\ | 当前输出记录的分隔符 |
| $] | Perl解释器的子版本号 |
| $^ | 当前通道最上面的页面输出格式名字 |
| $^A | 打印前用于保存格式化数据的变量 |
| $^D | 调试标志的值 |
| $^E | 在非UNIX环境中的操作系统扩展错误信息 |
| $^F | 最大的文件捆述符数值 |
| $^H | 由编译器激活的语法检查状态 |
| $^I | 内置控制编辑器的值 |
| $^L | 发送到输出通道的走纸换页符 |
| $^M | 备用内存池的大小 |
| $^O | 操作系统名 |
| $^P | 指定当前调试值的内部变量 |
| $^R | 正则表达式块的上次求值结果 |
| $^S | 当前解释器状态 |
| $^T | 从新世纪开始算起,脚步本以秒计算的开始运行的时间 |
| $^W | 警告开关的当前值 |
| $^X | Perl二进制可执行代码的名字 |
| $_ | 默认的输入/输出和格式匹配空间 |
| $| | 控制对当前选择的输出文件句柄的缓冲 |
| $~ | 当前报告格式的名字 |
| $` | 在上个格式匹配信息前的字符串 |
| $’ | 在上个格式匹配信息后的字符串 |
| $+ | 与上个正则表达式搜索格式匹配的最后一个括号 |
| $< | 当前执行解释器的用户的真实ID |
| $  | 含有与上个匹配正则表达式对应括号结果 |
| $= | 当前页面可打印行的数目 |
| $> | 当前进程的有效用户ID |
| $0 | 包含正在执行的脚本的文件名 |
| $ARGV | 从默认的文件句柄中读取时的当前文件名 |
| %ENV | 环境变量列表 |
| %INC | 通过do或require包含的文件列表 |
| %SIG | 信号列表及其处理方式 |
| @_ | 传给子程序的参数列表 |
| @ARGV | 传给脚本的命令行参数列表 |
| @INC | 在导入模块时需要搜索的目录列表 |
| $-[0] | 代表当前匹配的正则表达式在被匹配的字符串中的起始位置 |
| $+[0] | 代表当前匹配的正则表达式在被匹配的字符串中的终止的位置 ||


